// Generated by `wit-bindgen-wrpc-go` 0.1.1. DO NOT EDIT!
package batch

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	wrpc__keyvalue__store "github.com/wrpc/keyvalue/imports/wrpc/keyvalue/store"
	wrpc "github.com/wrpc/wrpc/go"
	io "io"
	slog "log/slog"
	math "math"
	sync "sync"
	atomic "sync/atomic"
	utf8 "unicode/utf8"
)

type Error = wrpc__keyvalue__store.Error

// Get the key-value pairs associated with the keys in the store. It returns a list of
// key-value pairs.
//
// If any of the keys do not exist in the store, it returns a `none` value for that pair in the
// list.
//
// MAY show an out-of-date value if there are concurrent writes to the store.
//
// If any other error occurs, it returns an `Err(error)`.
func GetMany(ctx__ context.Context, wrpc__ wrpc.Invoker, bucket string, keys []string) (r0__ *wrpc.Result[[]*wrpc.Tuple2[string, []uint8], Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wrpc:keyvalue/batch@0.2.0-draft", "get-many", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(bucket, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `bucket` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v []string, w interface {
			io.ByteWriter
			io.Writer
		}) (write func(wrpc.IndexWriter) error, err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing list length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
			}
			slog.Debug("writing list elements")
			writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
			for i, e := range v {
				write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(e, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
				}
				if write != nil {
					writes[uint32(i)] = write
				}
			}
			if len(writes) > 0 {
				return func(w wrpc.IndexWriter) error {
					var wg sync.WaitGroup
					var wgErr atomic.Value
					for index, write := range writes {
						wg.Add(1)
						w, err := w.Index(index)
						if err != nil {
							return fmt.Errorf("failed to index writer: %w", err)
						}
						write := write
						go func() {
							defer wg.Done()
							if err := write(w); err != nil {
								wgErr.Store(err)
							}
						}()
					}
					wg.Wait()
					err := wgErr.Load()
					if err == nil {
						return nil
					}
					return err.(error)
				}, nil
			}
			return nil, nil
		}(keys, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `keys` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[[]*wrpc.Tuple2[string, []uint8], Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) ([]*wrpc.Tuple2[string, []uint8], error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading list length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return nil, fmt.Errorf("failed to read list length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return nil, errors.New("list length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							vs := make([]*wrpc.Tuple2[string, []uint8], x)
							for i := range vs {
								slog.Debug("reading list element", "i", i)
								vs[i], err = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Tuple2[string, []uint8], error) {
									slog.Debug("reading option status byte")
									status, err := r.ReadByte()
									if err != nil {
										return nil, fmt.Errorf("failed to read option status byte: %w", err)
									}
									switch status {
									case 0:
										return nil, nil
									case 1:
										slog.Debug("reading `option::some` payload")
										v, err := func(r wrpc.IndexReader, path ...uint32) (*wrpc.Tuple2[string, []uint8], error) {
											v := &wrpc.Tuple2[string, []uint8]{}
											var err error
											slog.Debug("reading tuple element 0")
											v.V0, err = func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint8
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if s == 28 && b > 0x0f {
														return "", errors.New("string length overflows a 32-bit integer")
													}
													if b < 0x80 {
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
											}
											slog.Debug("reading tuple element 1")
											v.V1, err = func(r interface {
												io.ByteReader
												io.Reader
											}) ([]byte, error) {
												var x uint32
												var s uint
												for i := 0; i < 5; i++ {
													slog.Debug("reading byte list length", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
													}
													if b < 0x80 {
														if i == 4 && b > 1 {
															return nil, errors.New("byte list length overflows a 32-bit integer")
														}
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading byte list contents", "len", x)
														_, err = io.ReadFull(r, buf)
														if err != nil {
															return nil, fmt.Errorf("failed to read byte list contents: %w", err)
														}
														return buf, nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return nil, errors.New("byte length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
										}
										return v, nil
									default:
										return nil, fmt.Errorf("invalid option status byte %d", status)
									}
								}(r, append(path, uint32(i))...)
								if err != nil {
									return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
								}
							}
							return vs, nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return nil, errors.New("list length overflows a 32-bit integer")
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[[]*wrpc.Tuple2[string, []uint8], Error]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (*Error, error) {
					v, err := func(r wrpc.IndexReader, path ...uint32) (*wrpc__keyvalue__store.Error, error) {
						v := &wrpc__keyvalue__store.Error{}
						n, err := func(r io.ByteReader) (uint8, error) {
							var x uint8
							var s uint
							for i := 0; i < 2; i++ {
								slog.Debug("reading u8 discriminant byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
								}
								if s == 7 && b > 0x01 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								if b < 0x80 {
									return x | uint8(b)<<s, nil
								}
								x |= uint8(b&0x7f) << s
								s += 7
							}
							return x, errors.New("discriminant overflows an 8-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read discriminant: %w", err)
						}
						switch wrpc__keyvalue__store.ErrorDiscriminant(n) {
						case wrpc__keyvalue__store.ErrorNoSuchStore:
							return v.SetNoSuchStore(), nil
						case wrpc__keyvalue__store.ErrorAccessDenied:
							return v.SetAccessDenied(), nil
						case wrpc__keyvalue__store.ErrorOther:
							payload, err := func(r interface {
								io.ByteReader
								io.Reader
							}) (string, error) {
								var x uint32
								var s uint8
								for i := 0; i < 5; i++ {
									slog.Debug("reading string length byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return "", fmt.Errorf("failed to read string length byte: %w", err)
									}
									if s == 28 && b > 0x0f {
										return "", errors.New("string length overflows a 32-bit integer")
									}
									if b < 0x80 {
										x = x | uint32(b)<<s
										buf := make([]byte, x)
										slog.Debug("reading string bytes", "len", x)
										_, err = r.Read(buf)
										if err != nil {
											return "", fmt.Errorf("failed to read string bytes: %w", err)
										}
										if !utf8.Valid(buf) {
											return string(buf), errors.New("string is not valid UTF-8")
										}
										return string(buf), nil
									}
									x |= uint32(b&0x7f) << s
									s += 7
								}
								return "", errors.New("string length overflows a 32-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `other` payload: %w", err)
							}
							return v.SetOther(payload), nil
						default:
							return nil, fmt.Errorf("unknown discriminant value %d", n)
						}
					}(r, path...)
					return (*Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[[]*wrpc.Tuple2[string, []uint8], Error]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `get-many`: %w", err__)
		return
	}
	return
}

// Set the values associated with the keys in the store. If the key already exists in the
// store, it overwrites the value.
//
// Note that the key-value pairs are not guaranteed to be set in the order they are provided.
//
// If any of the keys do not exist in the store, it creates a new key-value pair.
//
// If any other error occurs, it returns an `Err(error)`. When an error occurs, it does not
// rollback the key-value pairs that were already set. Thus, this batch operation does not
// guarantee atomicity, implying that some key-value pairs could be set while others might
// fail.
//
// Other concurrent operations may also be able to see the partial results.
func SetMany(ctx__ context.Context, wrpc__ wrpc.Invoker, bucket string, keyValues []*wrpc.Tuple2[string, []uint8]) (r0__ *wrpc.Result[struct{}, Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wrpc:keyvalue/batch@0.2.0-draft", "set-many", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(bucket, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `bucket` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v []*wrpc.Tuple2[string, []uint8], w interface {
			io.ByteWriter
			io.Writer
		}) (write func(wrpc.IndexWriter) error, err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing list length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
			}
			slog.Debug("writing list elements")
			writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
			for i, e := range v {
				write, err := func(v *wrpc.Tuple2[string, []uint8], w interface {
					io.ByteWriter
					io.Writer
				}) (func(wrpc.IndexWriter) error, error) {
					writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
					slog.Debug("writing tuple element 0")
					write0, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
						n := len(v)
						if n > math.MaxUint32 {
							return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
						}
						if err = func(v int, w io.Writer) error {
							b := make([]byte, binary.MaxVarintLen32)
							i := binary.PutUvarint(b, uint64(v))
							slog.Debug("writing string byte length", "len", n)
							_, err = w.Write(b[:i])
							return err
						}(n, w); err != nil {
							return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
						}
						slog.Debug("writing string bytes")
						_, err = w.Write([]byte(v))
						if err != nil {
							return fmt.Errorf("failed to write string bytes: %w", err)
						}
						return nil
					}(v.V0, w)
					if err != nil {
						return nil, fmt.Errorf("failed to write tuple element 0: %w", err)
					}
					if write0 != nil {
						writes[0] = write0
					}
					slog.Debug("writing tuple element 1")
					write1, err := func(v []uint8, w interface {
						io.ByteWriter
						io.Writer
					}) (write func(wrpc.IndexWriter) error, err error) {
						n := len(v)
						if n > math.MaxUint32 {
							return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
						}
						if err = func(v int, w io.Writer) error {
							b := make([]byte, binary.MaxVarintLen32)
							i := binary.PutUvarint(b, uint64(v))
							slog.Debug("writing list length", "len", n)
							_, err = w.Write(b[:i])
							return err
						}(n, w); err != nil {
							return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
						}
						slog.Debug("writing list elements")
						writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
						for i, e := range v {
							write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
								slog.Debug("writing u8 byte")
								return w.WriteByte(v)
							}(e, w)
							if err != nil {
								return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
							}
							if write != nil {
								writes[uint32(i)] = write
							}
						}
						if len(writes) > 0 {
							return func(w wrpc.IndexWriter) error {
								var wg sync.WaitGroup
								var wgErr atomic.Value
								for index, write := range writes {
									wg.Add(1)
									w, err := w.Index(index)
									if err != nil {
										return fmt.Errorf("failed to index writer: %w", err)
									}
									write := write
									go func() {
										defer wg.Done()
										if err := write(w); err != nil {
											wgErr.Store(err)
										}
									}()
								}
								wg.Wait()
								err := wgErr.Load()
								if err == nil {
									return nil
								}
								return err.(error)
							}, nil
						}
						return nil, nil
					}(v.V1, w)
					if err != nil {
						return nil, fmt.Errorf("failed to write tuple element 1: %w", err)
					}
					if write1 != nil {
						writes[1] = write1
					}
					if len(writes) > 0 {
						return func(w wrpc.IndexWriter) error {
							var wg sync.WaitGroup
							var wgErr atomic.Value
							for index, write := range writes {
								wg.Add(1)
								w, err := w.Index(index)
								if err != nil {
									return fmt.Errorf("failed to index writer: %w", err)
								}
								write := write
								go func() {
									defer wg.Done()
									if err := write(w); err != nil {
										wgErr.Store(err)
									}
								}()
							}
							wg.Wait()
							err := wgErr.Load()
							if err == nil {
								return nil
							}
							return err.(error)
						}, nil
					}
					return nil, nil
				}(e, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
				}
				if write != nil {
					writes[uint32(i)] = write
				}
			}
			if len(writes) > 0 {
				return func(w wrpc.IndexWriter) error {
					var wg sync.WaitGroup
					var wgErr atomic.Value
					for index, write := range writes {
						wg.Add(1)
						w, err := w.Index(index)
						if err != nil {
							return fmt.Errorf("failed to index writer: %w", err)
						}
						write := write
						go func() {
							defer wg.Done()
							if err := write(w); err != nil {
								wgErr.Store(err)
							}
						}()
					}
					wg.Wait()
					err := wgErr.Load()
					if err == nil {
						return nil
					}
					return err.(error)
				}, nil
			}
			return nil, nil
		}(keyValues, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `key-values` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, Error]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (*Error, error) {
					v, err := func(r wrpc.IndexReader, path ...uint32) (*wrpc__keyvalue__store.Error, error) {
						v := &wrpc__keyvalue__store.Error{}
						n, err := func(r io.ByteReader) (uint8, error) {
							var x uint8
							var s uint
							for i := 0; i < 2; i++ {
								slog.Debug("reading u8 discriminant byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
								}
								if s == 7 && b > 0x01 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								if b < 0x80 {
									return x | uint8(b)<<s, nil
								}
								x |= uint8(b&0x7f) << s
								s += 7
							}
							return x, errors.New("discriminant overflows an 8-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read discriminant: %w", err)
						}
						switch wrpc__keyvalue__store.ErrorDiscriminant(n) {
						case wrpc__keyvalue__store.ErrorNoSuchStore:
							return v.SetNoSuchStore(), nil
						case wrpc__keyvalue__store.ErrorAccessDenied:
							return v.SetAccessDenied(), nil
						case wrpc__keyvalue__store.ErrorOther:
							payload, err := func(r interface {
								io.ByteReader
								io.Reader
							}) (string, error) {
								var x uint32
								var s uint8
								for i := 0; i < 5; i++ {
									slog.Debug("reading string length byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return "", fmt.Errorf("failed to read string length byte: %w", err)
									}
									if s == 28 && b > 0x0f {
										return "", errors.New("string length overflows a 32-bit integer")
									}
									if b < 0x80 {
										x = x | uint32(b)<<s
										buf := make([]byte, x)
										slog.Debug("reading string bytes", "len", x)
										_, err = r.Read(buf)
										if err != nil {
											return "", fmt.Errorf("failed to read string bytes: %w", err)
										}
										if !utf8.Valid(buf) {
											return string(buf), errors.New("string is not valid UTF-8")
										}
										return string(buf), nil
									}
									x |= uint32(b&0x7f) << s
									s += 7
								}
								return "", errors.New("string length overflows a 32-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `other` payload: %w", err)
							}
							return v.SetOther(payload), nil
						default:
							return nil, fmt.Errorf("unknown discriminant value %d", n)
						}
					}(r, path...)
					return (*Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, Error]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `set-many`: %w", err__)
		return
	}
	return
}

// Delete the key-value pairs associated with the keys in the store.
//
// Note that the key-value pairs are not guaranteed to be deleted in the order they are
// provided.
//
// If any of the keys do not exist in the store, it skips the key.
//
// If any other error occurs, it returns an `Err(error)`. When an error occurs, it does not
// rollback the key-value pairs that were already deleted. Thus, this batch operation does not
// guarantee atomicity, implying that some key-value pairs could be deleted while others might
// fail.
//
// Other concurrent operations may also be able to see the partial results.
func DeleteMany(ctx__ context.Context, wrpc__ wrpc.Invoker, bucket string, keys []string) (r0__ *wrpc.Result[struct{}, Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wrpc:keyvalue/batch@0.2.0-draft", "delete-many", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(bucket, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `bucket` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v []string, w interface {
			io.ByteWriter
			io.Writer
		}) (write func(wrpc.IndexWriter) error, err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing list length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
			}
			slog.Debug("writing list elements")
			writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
			for i, e := range v {
				write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(e, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
				}
				if write != nil {
					writes[uint32(i)] = write
				}
			}
			if len(writes) > 0 {
				return func(w wrpc.IndexWriter) error {
					var wg sync.WaitGroup
					var wgErr atomic.Value
					for index, write := range writes {
						wg.Add(1)
						w, err := w.Index(index)
						if err != nil {
							return fmt.Errorf("failed to index writer: %w", err)
						}
						write := write
						go func() {
							defer wg.Done()
							if err := write(w); err != nil {
								wgErr.Store(err)
							}
						}()
					}
					wg.Wait()
					err := wgErr.Load()
					if err == nil {
						return nil
					}
					return err.(error)
				}, nil
			}
			return nil, nil
		}(keys, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `keys` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, Error]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (*Error, error) {
					v, err := func(r wrpc.IndexReader, path ...uint32) (*wrpc__keyvalue__store.Error, error) {
						v := &wrpc__keyvalue__store.Error{}
						n, err := func(r io.ByteReader) (uint8, error) {
							var x uint8
							var s uint
							for i := 0; i < 2; i++ {
								slog.Debug("reading u8 discriminant byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
								}
								if s == 7 && b > 0x01 {
									return x, errors.New("discriminant overflows an 8-bit integer")
								}
								if b < 0x80 {
									return x | uint8(b)<<s, nil
								}
								x |= uint8(b&0x7f) << s
								s += 7
							}
							return x, errors.New("discriminant overflows an 8-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read discriminant: %w", err)
						}
						switch wrpc__keyvalue__store.ErrorDiscriminant(n) {
						case wrpc__keyvalue__store.ErrorNoSuchStore:
							return v.SetNoSuchStore(), nil
						case wrpc__keyvalue__store.ErrorAccessDenied:
							return v.SetAccessDenied(), nil
						case wrpc__keyvalue__store.ErrorOther:
							payload, err := func(r interface {
								io.ByteReader
								io.Reader
							}) (string, error) {
								var x uint32
								var s uint8
								for i := 0; i < 5; i++ {
									slog.Debug("reading string length byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return "", fmt.Errorf("failed to read string length byte: %w", err)
									}
									if s == 28 && b > 0x0f {
										return "", errors.New("string length overflows a 32-bit integer")
									}
									if b < 0x80 {
										x = x | uint32(b)<<s
										buf := make([]byte, x)
										slog.Debug("reading string bytes", "len", x)
										_, err = r.Read(buf)
										if err != nil {
											return "", fmt.Errorf("failed to read string bytes: %w", err)
										}
										if !utf8.Valid(buf) {
											return string(buf), errors.New("string is not valid UTF-8")
										}
										return string(buf), nil
									}
									x |= uint32(b&0x7f) << s
									s += 7
								}
								return "", errors.New("string length overflows a 32-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `other` payload: %w", err)
							}
							return v.SetOther(payload), nil
						default:
							return nil, fmt.Errorf("unknown discriminant value %d", n)
						}
					}(r, path...)
					return (*Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, Error]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `delete-many`: %w", err__)
		return
	}
	return
}
